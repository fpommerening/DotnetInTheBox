<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>.net in the box</title>

		<meta name="description" content=".NET in the Box">
    	<meta name="author" content="Frank Pommerening">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

	<style>
		a.infolink {
			width: 40px;
			height: 40px;
			display: inline-block;
			background-image: url("images/about.svg");
			background-size:cover;

		}
    </style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
				<h1>.net in the box</h1>
                <h2>.NET User Group Leipzig</h2>
				<h3>25.04.2017</h3>
            	</section>
				<section>
				  <section>
                    <h2>Frank Pommerening</h2>
                    <img src="images/fp.jpg" style="border:0px;width:175px">
                    <ul>
                        <li>Senior - Softwareentwickler</li>
                        <li>Consultant</li>
                        <li>Softwarearchitekt</li>
                    </ul>
                    <br />
                    <br />
                    <a href="mailto:frank@pommerening-online.de">frank@pommerening-online.de</a>
                </section>
				 <section data-background="images/axp.svg">
				
                    AXP Consulting GmbH & Co. KG in Leipzig<br/>
                    Gründung: Mai 2012 <br />
                    Anzahl Mitarbeiter:	8 feste <br/>
                    Branchenfokus: Energiebranche <br/>
					<br/>
					<br/>
                    <ul>

                    <li>Consulting (fachlich & IT)
<ul>
    <li>Requirements Engineering / Projektmanagement </li>
    <li>IT-Fachprozess-Analyse / Dokumentation</li>
</ul>
                    </li>
                    <li>Software-Entwicklung
                        <ul>
                            <li>Microservices, SOA, REST, OOA und OOD</li>
                             <li>Microsoft Technologien z.B. .NET (C#), WPF, WCF</li>
<li>Datenbanken (MS SQL Server / Oracle  / MongoDB)
                            </ul>
                        </li>
                    </ul>
                </section>
            </section>
			
			<section>
				<section>
					<h2>Build .Net Core App</h2>
					<img src="images/DockerDotNET.jpg" alt="Logo .net and docker"/ style="border: 0; height: 500px">
				</section>
				<section>
					<h3>Build inside</h3>
					Die Anwendung wird im Container während der Imageerstellung gebaut.
					<br />
					<br />
<table>
	 <tbody>
		 <tr>
			 <th>Vorteile</th>
			 <th>Nachteile</th>
		 </tr>
		 <tr>
			 <td>
				<ul>
					<li>Buildserver nicht erforderlich</li>
					<li>Weniger komplex</li>
				</ul>
			 </td>
			<td>
				<ul>
					<li>Quellcode und Buildabhängigkeiten ggf. im Image enthalten</li>
					<li>Basisimage größer (SDK erforderlich)</li>
					<li>i.d.R. entstehen größere Images</li>
					<li>Buildfehler schwerer zu debuggen</li>
				</ul>
			</td>
		 </tr>
</tbody>
</table>
				</section>
				<section>
					<h3>Build outside</h3>
					Die Anwendung wird unabhängig vom Container erstellt. Die entstandenen Artefakte werden bei der Imageerstellung kopiert.
					<br />
					<br />
			<table>
	 <tbody>
		 <tr>
			 <th>Vorteile</th>
			 <th>Nachteile</th>
		 </tr>
		 <tr>
			 <td>
				<ul>
					<li>i.d.R. kleinere Images und Basisimages</li>
					<li>Build unabhängig von der Imageestellung</li>
					<li>Quellcode und Buildabhängigkeiten nicht enthalten</li>
				</ul>
			 </td>
			<td>
				<ul>
					<li>Infrastruktur für Build erforderlich</li>
					<li>Trennung erzeugt Komplexität</li>
				</ul>
			</td>
		 </tr>
</tbody>
</table>
				</section>
			</section>
			<section>
				<section>
					<h2>Containerfertige .Net (Core) App</h2>
					<img src="images/DockerDotNET.jpg" alt="Logo .net and docker"/ style="border: 0; height: 500px">
				</section>
				<section>
					<h3>Konfiguration / Einstellungen</h3>
					<ul>
						<li>Einfache Implementierung in .NET Anwendung</li>
						<li>Gute Integration in Docker-Ökosystem</li>
						<li>Plattformabhängigkeit</li>
						<li>Support von verschiedenen Umgebungen: Entwicklung, Test und Produktion</li>
					<ul>
						<br />
			<table>
	 <tbody>
		 <tr>
			 <th>Ungeeignet</th>
			 <th>Alternativen</th>
		 </tr>
		 <tr>
			 <td>Registry</td>
			 <td>Zentrale Service-Discovery</td>
		 </tr>
		 <tr>
			 <td>Config-Dateien</td>
			 <td>Environment Variables</td>
		 </tr>
</tbody>
</table>
				</section>
				<section>
					<h3>Logging <span class="fragment"> JA</span> </h3>
					<br />
					<span class="fragment">Datei</span> <span class="fragment"> NEIN</span><br />
					<span class="fragment">Console</span> <span class="fragment">JA</span><br />
					<span class="fragment">aber formatiert</span>
					<br />
					<br />
					<span class="fragment">
					Vorteile
					<br />
					<ul>
						<li>Kein Problem mit verteilte Umgebung</li>
						<li>Gute Integration ins Ökosystem</li>
						<li>Einfach zu implementieren</li>
					</ul>
					</span>
					
				</section>
				<section>
					<h3>Microservice mit .net</h3>
					<ul>
						<li>Verwendung eines gemeinsamen Basisimage 
							<ul>
								<li>Gleiche Version von .net und Abhängigkeiten für alle Serviceimages</li>
								<li>Geringere Build-Zeiten</li>
							</ul>
						</li>
						<li>Infrastruktur-Container ggf. trotz Abhängigkeit  noch nicht verfügbar (Reliability / Retry) </li>
						<li>Build outside bevorzugen</li>
						<li>Linux-Container besser auf Linux statt Windows-Host erstellen</li>
					</ul>
				</section>
				<section>
                     <h2>Image-Workflow</h2>
                     <img src="images/ImageProcessing.svg"  style="border:0px;width:800px" alt="Beispiel PicFlow">
                 </section>
			</section>
			<section>
				<section>
					<h2>Docker auf Raspberry PI 3</h2>
				</section>
				<section>
					<h3>Build .net App</h3>
					Die Unterstützung der ARM-Plattform für .net core ist noch in Entwicklung.
					Deshalb sollte man aktuell auf Mono von Xamarin / Microsoft zurückgreifen.
					<br />
					<br />
					Images die auf x86/x64 erstellt wurden, sind auf dem Raspberry nicht lauffähig!
					<br />
					<br />
					Verwendung spezieller Basisimages erforderlich<br />
					<ul>
						<li>resin/rpi-raspbian</li>
						<li>resin/raspberrypi3-debian</li>
						<li>yyolk/rpi-archlinuxarm</li>
						<li>ioft/armhf-ubuntu</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>GitHub + Docker Hub</h2>
				</section>
				<section>
				Die Verknüpfung von GitHub und Docker Hub gestattet eine automatische Erstellung der Container mit jeder Codeänderung.
				<img src="images/githubdockerhub.svg" alt="schema flow github and dockerhub" style="border: 0"/>
				Voraussetzungen:
				<ul>
					<li>Accounts bei GitHub und Docker Hub existieren</li>
					<li>Quellcode inkl. Dockerfile ist in einem Repository auf GitHub vorhanden</li>
				</ul>
				</section>
				<section>
					<h3>Verbindung GitHub und Docker Hub</h3>
					<ol start="1">
						<li>Login bei Docker Hub</li>
						<li>Profil -> Setting -> Linked Accounts & Services</li>
					</ol>
					<img src="images/gitdocker_01.png" style="height: 350px"/>
				</section>
				<section>
					<ol start="3">
						<li>Auswahl des Zugriffs</li>
					</ol>
					<br />
					<img src="images/gitdocker_02.png" style="height: 500px"/>
				</section>
				<section>
					<ol start="4">
						<li>Autorisierung des Zugriffs</li>
						<li>Bestätigung mit GitHub-Kennwort</li>
					</ol>
					<br />
					<img src="images/gitdocker_03.png" style="height: 400px"/>
					<img src="images/gitdocker_04.png" style="height: 250px"/>
				</section>
				<section>
					<h3>Automatischer Build</h3>
					<ol>
						<li>Login bei Docker Hub</li>
						<li>Create -> Create Automated Build</li>
						<li>Auswahl Herkunft Quellcode (GitHub oder Bitbucket)</li>
					</ol><br />
					<img src="images/gitdocker_05.png" style="height: 400px"/>
				</section>
				<section>
					<ol start="4">
						<li>Auswahl des Quell-Repository</li>
					</ol>
					<img src="images/gitdocker_06.png" style="height: 250px"/>
					
				</section>
				<section>
					<ol start="5">
						<li>Konfiguration Docker Hub-Repository
						<ul>
							<li>Namespace (Fix: Benutzer)</li>
							<li>Name (Default: Name des GitHub-Repository)</li>
							<li>Sichtbarkeit (Default: Öffentlich)</li>
							<li>Kurzbeschreibung (Pflichtfeld)</li>
						</ul>
						</li>
					</ol>
					<br />
					<img src="images/gitdocker_07.png" style="height: 400px"/>
				</section>
				<section>
					<ol start="6">
						<li>Anpassung Build-Einstellungen (Build-Settings)
							<ul>
								<li>Pfad zum Dockerfile</li>
								<li>Definition Tags</li>
								<li>Verwendete Git-Branches</li>
							</ul>
						</li>
					</ol>
					<img src="images/gitdocker_08.png" style="height: 400px"/>
				</section>
				<section>
					<ol start="7">
						<li>Prüfung Build (Build Details)</li>
					</ol>
					<img src="images/gitdocker_09.png" style="height: 400px"/>
				</section>
			</section>
			<section>
				<section>
					<h2>.Net Client API</h2>
				</section>
				<section>
					Eine .NET Client API wird offiziell von Microsoft gepflegt.
					<br />
					Quellcode: <a href="https://github.com/Microsoft/Docker.DotNet" target="_blank">GitHub</a>
					<br />
					Package: <a href="https://www.nuget.org/packages/Docker.DotNet/" target="_blank">Nuget</a>
					<br />
					Hinweis: Die Pakete werden nicht synchron mit den Änderungen am Quellcode veröffentlicht. 
					Bestimmte Funktionen z.B. die Unterstützung für Swarm steht nur als Quellcode bereit.
				</section>
				<section>
					<h3>Verbindungsaufbau</h3>
					Für den Aufbau der Verbindung können verschiedene Protokolle z.B. Http oder Linux-Sockets verwendet.
					Letztes erlaubt auch die Verwendung in einem Container.
					<br />
					<br />
					Windows (Docker for Windows)
					<br />
					<pre><code class="cs">var client = new DockerClientConfiguration(new Uri(http://localhost:2375)).CreateClient();</code></pre>
					<br />
					Linux (innerhalb eines Container)
					<pre><code class="cs">var client = new DockerClientConfiguration(new Uri(unix://var/run/docker.sock)).CreateClient();</code></pre>
					Bei Start benötigt der Container zusätzliche Rechte<br />
					<pre><code class="docker">docker run -d --privileged user/myimage</code></pre>
				</section>
				<section>
					<h3>Abfrage Images</h3>
					<pre><code class="cs">var imageParams = new ImagesListParameters{ MatchName = "ubuntu" };
var images = await client.Images.ListImagesAsync(imageParams);</code></pre>
					<br /><br />
						<h3>Abfrage Container</h3>
						 <pre><code class="cs">var listParam = new ContainersListParameters
            {
                Filters = new Dictionary&lt;string, IDictionary&lt;string, bool&gt;&gt;
                {
                    {"name", new Dictionary&lt;string, bool&gt; {{"pingtest", true}}}
                }
            };
var result = await client.Containers.ListContainersAsync(listParam)</code></pre>
				</section>
				<section>
					<h3>Container erstellen</h3>
					Das Ergebnis der Erstellung enthält u.a. die vergebene Container-ID. <br />
					Wichtig: Erstellte Container sind nicht gestartet.
					<pre><code class="cs">var createParam = new CreateContainerParameters
            {   Image = "ubuntu:latest",
                Cmd = new List&lt;string&gt; {"echo", "hallo world"},
                Name = "halloworldtest"     };
var result =  await client.Containers.CreateContainerAsync(createParam);</code></pre>
				<h3>Container starten</h3>
				<pre><code class="cs">await client.Containers.StartContainerAsync(containerId, null);</code></pre>
				<h3>Container stoppen</h3>
				<pre><code class="cs">await client.Containers.StopContainerAsync(containerId, 
	new ContainerStopParameters(), CancellationToken.None);</code></pre>
				</section>
				<section>
					Beispiel: Webhook für automatische Bereitstellung
				</section>
				<section>
					<h3>Konfiguration des Webhook</h3>
					<img src="images/webhock_01.png" style="height: 350px; float: right">
					<ol>
						<li>Login beim Docker Hub</li>
						<li>Auswahl des Repository</li>
						<li>Webhooks -> Create a Webhook</li>
						<li>Name und Ziel-URL festlegen</li>
						<li>Speichern</li>
					</ol>
					<img src="images/webhock_02.png" style="height: 150px; float: left">
				</section>
			</section>
			<!--
			<section>
					<h2>CI / DC mit TFS / Visual Studio Team Services</h2>
			</section>
			-->
			<section>
				<h3>Quellen:</h3>
				https://blog.docker.com/media/Rancher-Logo-Final-1.png
				http://design.ubuntu.com/wp-content/uploads/ubuntu-logo14.png
				https://www.archlinux.org/static/logos/archlinux-logo-dark-1200dpi.b42bd35d5916.png
				http://blog.d2-si.fr/2016/06/29/start-up-docker-swarm/
				http://www.willhoeft-it.com/2016/06/03/docker-compose.html
				https://blogs.msdn.microsoft.com/cesardelatorre/2016/11/16/free-ebook-on-containerized-docker-application-lifecycle-with-microsoft-tools-and-platform/
				https://www.docker.com/sites/default/files/oyster-registry-3.png
				http://blog.terranillius.com/post/composev3_swarm/
			</section>


			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
            	progress: true,
            	history: true,
            	center: true,
            	width: 1250,
            	height: 720,
            	slideNumber: false,
            	margin: 0.0,

				multiplex: {
                 // Example values. To generate your own, see the socket.io server instructions.
                	secret: null, // null so the clients do not have control of the master presentation
                 	id: '0f44bb6f2194e219', // id, obtained from socket.io server
                	url: 'https://reveal-js-multiplex-ccjbegmaii.now.sh' // Location of socket.io server
            		},

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function () { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
					{ src: 'plugin/markdown/markdown.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/zoom-js/zoom.js', async: true },
                    { src: 'plugin/notes/notes.js', async: true },
                    { src: '//cdn.socket.io/socket.io-1.3.5.js', async: true },
                    { src: 'plugin/multiplex/client.js', async: true }
				]
			});
		</script>
	</body>
</html>
